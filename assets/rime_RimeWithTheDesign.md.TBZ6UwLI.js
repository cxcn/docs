import{_ as n,c as s,o as a,U as e}from"./chunks/framework.WKpLpN6N.js";const u=JSON.parse('{"title":"概念解讀","description":"","frontmatter":{},"headers":[],"relativePath":"rime/RimeWithTheDesign.md","filePath":"home.wiki/RimeWithTheDesign.md"}'),p={name:"rime/RimeWithTheDesign.md"},i=e(`<blockquote><p>La Rime 架構設計解讀</p></blockquote><h1 id="概念解讀" tabindex="-1">概念解讀 <a class="header-anchor" href="#概念解讀" aria-label="Permalink to &quot;概念解讀&quot;">​</a></h1><h2 id="框架" tabindex="-1">框架 <a class="header-anchor" href="#框架" aria-label="Permalink to &quot;框架&quot;">​</a></h2><p>輸入法工作於需要輸入文本的程序中，後者就叫他做輸入法的「客戶程序」吧。</p><p>如果輸入法同時在不同的程序中工作，每個客戶程序裏的輸入內容都是不同的。 所以需要爲每個客戶維護輸入法狀態，術語稱輸入法「上下文／Context」。</p><p>邏輯複雜的輸入法，常常有個獨立的程序來做運算，便於集中管理詞庫等資源。 Rime稱其爲「服務／Service」，形式爲一個無介面表現的後臺程序／Backend。</p><p>於是輸入法的「前端／Frontend」，即輸入法在客戶程序中的那部份，可依託於後臺的服務來運作，自身只需關注與操作系統交互，以及將消息向服務轉發。</p><p>Rime的Frontend/Backend模型，依照ibus、IMK等輸入法框架來設計：Frontend不含輸入邏輯，甚至不負責繪製輸入法介面。因此會比較容易適配現有的輸入法框架，不需要自己寫很多代碼。</p><p>在服務中，會爲每一個客戶建立一個輸入法「會話／Session」。從功能上講，會話是將一系列按鍵消息變（Convert）爲文字的問（Request）答（Response）過程。</p><p>技術上講，會話會負責搞定輸入法前端與服務之間的跨進程通信，同時在服務端爲前端所代表的客戶分配必要的資源。這資源主要是指一部有狀態的、懂得所有輸入轉換邏輯的輸入法引擎「Engine」。</p><p>現在所寫的Rime庫，不做那框架部份，專注於輸入引擎的實現。 名字也叫「中州韻輸入法引擎／RIME」嘛。</p><p>這部份定義的代碼是 <a href="https://github.com/rime/librime" target="_blank" rel="noreferrer">rime/librime</a>，under C++ namespace <code>rime</code>。 拋開實際的輸入法框架，俺先寫個控制臺程序 <code>RimeConsole</code> 來模擬輸入，觀察Engine的輸出，以驗證其功能是否符合設計。</p><h2 id="引擎" tabindex="-1">引擎 <a class="header-anchor" href="#引擎" aria-label="Permalink to &quot;引擎&quot;">​</a></h2><p>輸入法的轉換邏輯自然是比較複雜，需要許多元件協同工作。要協同工作，比得組裝到一起，外面再加個殼。通常的機器都是如此，有外殼做封裝，看不到內部的元件，通過有限的幾處機關來操作，用起來比較省心。</p><p>Engine 對象，便是 Session 需要直接操作的介面。 除此之外，Rime庫還對外提供若干用於輸入輸出的數據對象。 包括他所持有的代表輸入法狀態的「上下文／Context」對象、 描述一份「輸入方案／Schema」的配置對象、 代表輸入按鍵的 <code>KeyEvent</code> 對象等。</p><p>開發者對 Engine 的期望，一是將來可不斷通過添加內部組件的方式增益其所不能，二是有能力動態地調整組件的調度，以在會話中切換到不同的輸入方式。</p><p>爲了避免知道得太多，這引擎的內部構造必須精巧，他存在的意義在於接合內部的各種組件、並對外提供可靠的接口：Engine所表達的邏輯僅限於此。</p><p>標準化Engine內部的「組件／Component」，明確與關鍵組件之間的對接方式，就可以滿足可擴展、可配置這兩點期望。</p><h1 id="設計與實現" tabindex="-1">設計與實現 <a class="header-anchor" href="#設計與實現" aria-label="Permalink to &quot;設計與實現&quot;">​</a></h1><h2 id="組件" tabindex="-1">組件 <a class="header-anchor" href="#組件" aria-label="Permalink to &quot;組件&quot;">​</a></h2><p>爲有好的擴展能力，定義一個接口來表示具有某種能力的一類組件； 爲了達到可在運行時動態配置的目的，採取抽象工廠的設計模式。</p><p><code>boost::factory</code>要求較高版本的Boost庫，所以我還是用了自家釀造的一套設施來做組件的包裝。</p><p>原則是，Rime中完成特定功能的對象，若只有一種實現方法，就寫個C++類／class；若有多種實現方法，就寫個「Rime類」／<code>rime::Class</code>。示意：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>class Processor : public Class&lt;Processor, Engine*&gt; {</span></span>
<span class="line"><span> public:</span></span>
<span class="line"><span>  Processor(Engine *engine) : engine_(engine) {}</span></span>
<span class="line"><span>  virtual ~Processor() {}</span></span>
<span class="line"><span>  // Processor的功能是處理按鍵消息</span></span>
<span class="line"><span>  virtual bool ProcessKeyEvent(const KeyEvent &amp;ke);</span></span>
<span class="line"><span> private:</span></span>
<span class="line"><span>  Engine *engine_;</span></span>
<span class="line"><span>};</span></span></code></pre></div><p>然後，大家就可以寫各式Processor的實現啦…… 當然，還要把每一種實現註冊爲具名的「組件」。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>class ToUpperCase : public Processor {</span></span>
<span class="line"><span> public:</span></span>
<span class="line"><span>  ToUpperCase(Engine *engine);</span></span>
<span class="line"><span>  virtual bool ProcessKeyEvent(const KeyEvent &amp;ke) {</span></span>
<span class="line"><span>    char ch = ke.ToAscii();</span></span>
<span class="line"><span>    if (islower(ch)) {</span></span>
<span class="line"><span>      engine_-&gt;CommitChar(ch - &#39;a&#39; + &#39;A&#39;);</span></span>
<span class="line"><span>      return true;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    return false;</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>};</span></span>
<span class="line"><span></span></span>
<span class="line"><span>void RegisterRimeComponents() {</span></span>
<span class="line"><span>  Registry.instance().Register(&quot;upper&quot;, new Component&lt;ToUpperCase&gt;);</span></span>
<span class="line"><span>  // 註冊各種組件到Registry...</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>用法：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>void UsingAProcessor() {</span></span>
<span class="line"><span>  // Class&lt;&gt;模板提供了簡便的方法，按名稱取得組件</span></span>
<span class="line"><span>  // Class&lt;T&gt;::Require() 從Registry中取得T::Component的指針</span></span>
<span class="line"><span>  // 而Component&lt;T&gt;繼承自T::Component，並實現了其中的純虛函數Create()</span></span>
<span class="line"><span>  Processor::Component* component = Processor::Require(&quot;upper&quot;);</span></span>
<span class="line"><span>  // 利用組件生成所需的對象</span></span>
<span class="line"><span>  KeyEvent key;   // 輸入</span></span>
<span class="line"><span>  Engine engine;  // 上屏文字由此輸出</span></span>
<span class="line"><span>  Processor* processor = component-&gt;Create(&amp;engine);</span></span>
<span class="line"><span>  bool taken = processor-&gt;ProcessKeyEvent(key);</span></span>
<span class="line"><span>  delete processor;</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>實際的代碼中，會將這個例子改造成Engine持有Processor對象，並轉發輸入按鍵給Processor。</p><h2 id="框架級組件和基礎組件" tabindex="-1">框架級組件和基礎組件 <a class="header-anchor" href="#框架級組件和基礎組件" aria-label="Permalink to &quot;框架級組件和基礎組件&quot;">​</a></h2><p>以Engine的視角，可以把各種組件分爲框架級組件和基礎組件。前者會由Engine創建並直接調用，故需要爲每一類組件定義明確的接口。後者作爲實現具體功能的積木，由框架級組件的實現類使用。</p><h3 id="框架級組件" tabindex="-1">框架級組件 <a class="header-anchor" href="#框架級組件" aria-label="Permalink to &quot;框架級組件&quot;">​</a></h3><p>目前設計中規劃了三類框架級組件：</p><ul><li>Processor，處理按鍵，編輯輸入串</li><li>Segmentor，解釋輸入串「是什麼」，將輸入串分段，標記輸入內容的可能類型</li><li>Translator，翻譯一段輸入，給出一組備選結果</li></ul><p>對於每一類組件，Engine將根據Schema中的配置，創建若干實例，並按一定規則調度，從而將複雜的輸入法邏輯分解到組件的各種實現裏，按輸入方案的需求組合。</p><p>當Engine接到前端傳來的按鍵消息，會順次調用一組Processor的ProcessKeyEvent()方法。 在這方法裏，每個Processor可決定是接受並處理該按鍵，放棄該按鍵還給系統做默認處理，還是留給其他的Processor來決定。</p><p>Processor的處理結果表現爲對Context的修改。當某個Processor修改了Context的編碼串時，Engine獲得信號通知，開始切分和翻譯的流程。</p><p>首先按次序由各Segmentor嘗試對編碼串分段。通過N個回合，將編碼串分爲N個編碼段。每一回合中，各Segmentor給出從編碼串指定位置開始可識別的最長編碼序列，及對應的編碼類型標籤。回合中最長的分段將被採納，將該編碼段的始末位置及一組編碼類型標籤記入Context中的分段信息。優先級較高的Segmentor也可以中止當前回合從而跳過優先級較低的Segmentor。</p><p>接下來，對每一個編碼段，調用各Translator做翻譯。Translator可憑藉編碼類型標籤來判斷本Translator能否完成該編碼段的翻譯。</p><p>每個Translator針對一個編碼段的翻譯結果爲Translation對象，是用來取得一組候選結果的迭代器。同一編碼段由不同Translator給出的Translations，存入Menu對象。爲了在有大量候選結果的情況下保持效率，Menu僅在需要時，譬如向後翻頁時，才會從Translation中取得一定數目的候選結果。 Translation有和其他Translation比較的方法，用於根據下一個候選結果的內容、或某種預定的策略來決定候選結果的排序。</p><p>Context中的Composition，匯總了分段信息、使用者在各代碼段對應的Menu中所選結果等信息。經過使用者手動確認結果、且未發生編輯動作的編碼段，將不再做重新分段的處理。</p><h3 id="基礎組件" tabindex="-1">基礎組件 <a class="header-anchor" href="#基礎組件" aria-label="Permalink to &quot;基礎組件&quot;">​</a></h3><p>TODO(lotem): 補完文檔</p><p>基礎組件：</p><ul><li>Dictionary, 詞典，由編碼序列檢索候選結果</li><li>UserDictionary, 動態的用戶詞典</li><li>Prism, 音節拼寫至詞典編碼的映射</li><li>Algebra, 拼寫運算規則</li><li>Syllablifier, 音節切分算法</li></ul>`,45),o=[i];function l(t,r,c,h,d,m){return a(),s("div",null,o)}const b=n(p,[["render",l]]);export{u as __pageData,b as default};
